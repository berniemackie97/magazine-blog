---
import type { CollectionEntry } from "astro:content";
import CoverRenderer from "./CoverRenderer.astro";
import type { CoverSpec, CoverBlock, CoverFeatureItem } from "../../lib/contentTypes";

interface Props {
  issue: CollectionEntry<"issues">;
  publication: CollectionEntry<"publications">;
  coverLines?: string[];
  showStatus?: boolean;
}

type IssueData = CollectionEntry<"issues">["data"] & {
  publicationId: string;
  issueSlug: string;
  displayTitle: string;
  volume: number;
  number: number;
  date: string;
  theme: string;
  status: "open" | "locked";
  coverSpec?: CoverSpec;
};

type PublicationData = CollectionEntry<"publications">["data"] & {
  name: string;
  defaultCoverSpec?: CoverSpec;
};

const { issue, publication, coverLines = [], showStatus = false } = Astro.props as Props;

const issueData = issue.data as IssueData;
const pubData = publication.data as PublicationData;

function safeText(value: unknown): string {
  return typeof value === "string" ? value.trim() : "";
}

function formatDate(value: string): string {
  const t = Date.parse(value);
  if (!Number.isFinite(t)) return value;
  return new Date(t).toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: "numeric",
  });
}

function buildFeatureItems(lines: string[]): CoverFeatureItem[] {
  const items: Array<CoverFeatureItem | null> = lines.map((line, idx) => {
    const text = safeText(line);
    if (!text) return null;
    return { no: String(idx + 1).padStart(2, "0"), text };
  });

  return items.filter((it): it is CoverFeatureItem => it !== null);
}

function fallbackSpec(publicationName: string): CoverSpec {
  return {
    template: "classic",
    layout: {
      cols: "1fr",
      areas: ["spine", "masthead", "meta", "art", "title", "featureList", "barcode", "cta"],
      gap: "0.75rem",
      pad: "12px 12px 12px 42px",
      minHeight: 520,
    },
    blocks: [
      { id: "spine", type: "spine", area: "spine", text: publicationName },
      { id: "masthead", type: "masthead", area: "masthead", publicationName },
      { id: "meta", type: "meta", area: "meta" },
      { id: "art", type: "art", area: "art" },
      { id: "title", type: "title", area: "title", title: "Untitled Issue" },
      { id: "featureList", type: "featureList", area: "featureList", items: [] },
      { id: "barcode", type: "barcode", area: "barcode" },
      { id: "cta", type: "cta", area: "cta", text: "Open issue" },
    ],
  };
}

function hydrateCoverSpec(base: CoverSpec): CoverSpec {
  const badge = `Vol ${issueData.volume} / No ${issueData.number}`;
  const dateText = formatDate(issueData.date);

  const featureLine = safeText(coverLines[0]) || safeText(issueData.theme);
  const insideLines =
    coverLines.length > 1
      ? coverLines.slice(1, 7)
      : [
          "Editor dispatch",
          "Field notes and tools",
          "One tiny weird sidebar",
        ];

  const injectedItems = buildFeatureItems(insideLines);

  const blocks: CoverBlock[] = base.blocks.map((block) => {
    if (block.type === "spine") {
      const text = safeText(block.text) || safeText(pubData.name);
      return { ...block, text };
    }

    if (block.type === "masthead") {
      const publicationName = safeText(block.publicationName) || safeText(pubData.name);
      const statusText =
        showStatus ? (issueData.status === "locked" ? "Locked" : "Open") : block.statusText;

      return { ...block, publicationName, statusText };
    }

    if (block.type === "title") {
      const title = safeText(block.title) || safeText(issueData.displayTitle) || "Untitled Issue";
      const dek = safeText(block.dek) || featureLine || undefined;
      return { ...block, title, dek };
    }

    if (block.type === "meta") {
      const left = safeText(block.left) || badge;
      const right = safeText(block.right) || dateText;
      return { ...block, left, right };
    }

    if (block.type === "featureList") {
      // If caller provides coverLines, treat them as the lineup for this card.
      // Otherwise, only fill if the CMS spec didnâ€™t provide items.
      const hasCmsItems = Array.isArray(block.items) && block.items.length > 0;
      const items = coverLines.length > 0 ? injectedItems : hasCmsItems ? block.items : injectedItems;
      return { ...block, items };
    }

    if (block.type === "cta") {
      const text = safeText(block.text) || "Open issue";
      return { ...block, text };
    }

    return block;
  });

  return { ...base, blocks };
}

const baseSpec =
  (issueData.coverSpec as CoverSpec | undefined) ??
  (pubData.defaultCoverSpec as CoverSpec | undefined) ??
  fallbackSpec(pubData.name);

const spec = hydrateCoverSpec(baseSpec);

const href = `/issues/${issueData.publicationId}/${issueData.issueSlug}`;
const ariaLabel = `${pubData.name}: ${issueData.displayTitle}`;
---

<CoverRenderer spec={spec} href={href} ariaLabel={ariaLabel} interactive />
